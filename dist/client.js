import H from"amqplib";import{v4 as B}from"uuid";class F{connection=null;channel=null;url;queues;callbacks={};constructor(h,w){this.url=h,this.queues=w}async connect(){try{this.connection=await H.connect(this.url),this.channel=await this.connection.createChannel(),await this.channel.assertQueue(this.queues.response),this.channel.consume(this.queues.response,(h)=>{if(h){const w=JSON.parse(h.content.toString()),x=this.callbacks[`${w.correlationId}`];if(x)x(w.result.send.error,w.result),delete this.callbacks[`${w.correlationId}`];this.channel?.ack(h)}})}catch(h){throw console.error("Error connecting to RabbitMQ:",h),h}}async addSMTPConfig(h,w){if(!this.channel)throw new Error("Not connected to RabbitMQ");const z={correlationId:B(),smtp:{[h]:w}};await this.channel.assertQueue(this.queues.request),this.channel.sendToQueue(this.queues.request,Buffer.from(JSON.stringify(z)))}async addTemplate(h,w){if(!this.channel)throw new Error("Not connected to RabbitMQ");const z={correlationId:B(),template:{[h]:w}};await this.channel.assertQueue(this.queues.request),this.channel.sendToQueue(this.queues.request,Buffer.from(JSON.stringify(z)))}async sendEmail({email:h,templateName:w,data:x,smtpName:z,callback:A}){if(!this.channel)throw new Error("Not connected to RabbitMQ");const D=B(),G={correlationId:D,send:{email:h,clientName:z||"default",templateName:w,data:x||{}}};if(A)this.callbacks[`${D}`]=A;await this.channel.assertQueue(this.queues.request),this.channel.sendToQueue(this.queues.request,Buffer.from(JSON.stringify(G)))}async sendEmailAndWaitForResult(h){return new Promise(async(w,x)=>{h.callback=(z,A)=>z?x(z):w(A),await this.sendEmail(h)})}async close(){if(this.channel)await this.channel.close();if(this.connection)await this.connection.close()}}var P=F;export{P as default};
