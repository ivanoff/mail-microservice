import F from"amqplib";import{v4 as G} from"uuid";class A{connection=null;channel=null;url;queues;callbacks=new Map;constructor(h,j){this.url=h,this.queues=j}async connect(){try{console.log(this.url),this.connection=await F.connect(this.url),console.log(this.url),this.channel=await this.connection.createChannel(),await this.channel.assertQueue(this.queues.response),this.channel.consume(this.queues.response,(h)=>{if(h){const j=JSON.parse(h.content.toString()),w=this.callbacks.get(j.uuid);if(w){if(j.success)w(null,j.result);else w(new Error(j.error),null);this.callbacks.delete(j.uuid)}this.channel?.ack(h)}})}catch(h){throw console.error("Error connecting to RabbitMQ:",h),h}}async addSMTPConfig(h,j){if(!this.channel)throw new Error("Not connected to RabbitMQ");const w={action:"add",clientName:h,config:j};await this.channel.assertQueue(this.queues.smtp),this.channel.sendToQueue(this.queues.smtp,Buffer.from(JSON.stringify(w)))}async addTemplate(h,j){if(!this.channel)throw new Error("Not connected to RabbitMQ");const w={action:"add",templateName:h,template:j};await this.channel.assertQueue(this.queues.template),this.channel.sendToQueue(this.queues.template,Buffer.from(JSON.stringify(w)))}async sendEmail({email:h,templateName:j,data:w,smtpName:B,callback:x}){if(!this.channel)throw new Error("Not connected to RabbitMQ");const z=G(),D={uuid:z,recipient:h,clientName:B||"default",templateName:j,data:w||{}};if(x)this.callbacks.set(z,x);await this.channel.assertQueue(this.queues.request),this.channel.sendToQueue(this.queues.request,Buffer.from(JSON.stringify(D)))}async close(){if(this.channel)await this.channel.close();if(this.connection)await this.connection.close()}}var M=A;export{M as default};
